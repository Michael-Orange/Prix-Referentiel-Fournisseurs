# AUTHENTIFICATION UNIFI√âE - PRIX-REFERENTIEL (APP PRINCIPALE)

## CONTEXTE
Tu es l'app PRINCIPALE. Tu vas impl√©menter l'authentification COMPL√àTE qui sera partag√©e avec GestionStockFP.

Cette app va :
1. Cr√©er la table users (partag√©e avec Stock)
2. Impl√©menter auth compl√®te (JWT, encryption)
3. Cr√©er les 4 users initiaux
4. Impl√©menter interface admin
5. Servir de r√©f√©rence pour duplication vers Stock

## PRINCIPES CL√âS

- Table users dans schema "referentiel" (partag√©e avec Stock)
- Passwords encrypt√©s (r√©versibles pour admin)
- JWT dans cookie HttpOnly (7 jours)
- Login par dropdown username + password
- Permissions par app (peut_acces_prix, peut_acces_stock)
- R√®gle : peut_acces_prix = true ‚Üí Acc√®s Prix ET Stock automatique

## STACK

Backend :
```bash
npm install jsonwebtoken crypto-js cookie-parser
npm install --save-dev @types/jsonwebtoken @types/cookie-parser
Frontend :
React Context pour auth state
TanStack Query
shadcn/ui components
PARTIE 1 : VARIABLES D'ENVIRONNEMENT
File: .env
AJOUTER ces lignes (g√©n√©rer secrets al√©atoires) :
# Secrets auth (GARDER PR√âCIEUSEMENT - √† copier aussi dans GestionStockFP)
JWT_SECRET=votre-secret-jwt-32-chars-minimum-ici
PASSWORD_SECRET_KEY=votre-cle-encryption-32-chars-minimum

# G√©n√©rer avec :
# node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
‚ö†Ô∏è IMPORTANT : Apr√®s g√©n√©ration, noter ces valeurs dans un fichier externe (tu devras les copier dans GestionStockFP).
PARTIE 2 : DATABASE
2.1 Sch√©ma users
File: shared/schema-users.ts (CR√âER)
import { pgSchema, serial, text, boolean, timestamp } from "drizzle-orm/pg-core";

export const referentielSchema = pgSchema("referentiel");

export const users = referentielSchema.table("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  nom: text("nom").notNull(),
  email: text("email").unique(),
  passwordEncrypted: text("password_encrypted").notNull(),
  
  peutAccesStock: boolean("peut_acces_stock").notNull().default(false),
  peutAccesPrix: boolean("peut_acces_prix").notNull().default(false),
  
  role: text("role").notNull().default("user"),
  actif: boolean("actif").notNull().default(true),
  
  dateCreation: timestamp("date_creation").notNull().defaultNow(),
  derniereConnexion: timestamp("derniere_connexion"),
  createdBy: text("created_by"),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export type User = typeof users.$inferSelect;
export type InsertUser = typeof users.$inferInsert;
2.2 Migration SQL
Ex√©cuter dans console DB (UNE SEULE FOIS) :
CREATE TABLE IF NOT EXISTS referentiel.users (
  id SERIAL PRIMARY KEY,
  username TEXT UNIQUE NOT NULL,
  nom TEXT NOT NULL,
  email TEXT UNIQUE,
  password_encrypted TEXT NOT NULL,
  
  peut_acces_stock BOOLEAN NOT NULL DEFAULT false,
  peut_acces_prix BOOLEAN NOT NULL DEFAULT false,
  
  role TEXT NOT NULL DEFAULT 'user',
  actif BOOLEAN NOT NULL DEFAULT true,
  
  date_creation TIMESTAMP NOT NULL DEFAULT NOW(),
  derniere_connexion TIMESTAMP,
  created_by TEXT,
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_users_username ON referentiel.users(username);
CREATE INDEX idx_users_actif ON referentiel.users(actif);
PARTIE 3 : BACKEND - UTILS
3.1 Password Encryption
File: server/utils/password-crypto.ts (CR√âER)
import CryptoJS from "crypto-js";

const SECRET_KEY = process.env.PASSWORD_SECRET_KEY || "fallback-secret";

if (!process.env.PASSWORD_SECRET_KEY) {
  console.warn("‚ö†Ô∏è  PASSWORD_SECRET_KEY non d√©finie");
}

export function encryptPassword(password: string): string {
  return CryptoJS.AES.encrypt(password, SECRET_KEY).toString();
}

export function decryptPassword(encryptedPassword: string): string {
  try {
    const bytes = CryptoJS.AES.decrypt(encryptedPassword, SECRET_KEY);
    return bytes.toString(CryptoJS.enc.Utf8);
  } catch (error) {
    console.error("Erreur d√©cryptage password:", error);
    return "";
  }
}
3.2 JWT Middleware
File: server/middleware/auth.ts (CR√âER)
import jwt from "jsonwebtoken";
import { Request, Response, NextFunction } from "express";

const JWT_SECRET = process.env.JWT_SECRET || "fallback-jwt";
const JWT_EXPIRES_IN = "7d";

if (!process.env.JWT_SECRET) {
  console.warn("‚ö†Ô∏è  JWT_SECRET non d√©finie");
}

export interface JWTPayload {
  userId: number;
  username: string;
  nom: string;
  role: "admin" | "user";
  apps: string[];
}

export function generateToken(payload: JWTPayload): string {
  return jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });
}

export function verifyToken(token: string): JWTPayload | null {
  try {
    return jwt.verify(token, JWT_SECRET) as JWTPayload;
  } catch (error) {
    return null;
  }
}

export function requireAuth(req: Request, res: Response, next: NextFunction) {
  const token = req.cookies?.auth_token;
  
  if (!token) {
    return res.status(401).json({ error: "Non authentifi√©" });
  }
  
  const payload = verifyToken(token);
  
  if (!payload) {
    return res.status(401).json({ error: "Token invalide" });
  }
  
  (req as any).user = payload;
  next();
}

export function requireAdmin(req: Request, res: Response, next: NextFunction) {
  const user = (req as any).user as JWTPayload;
  
  if (!user || user.role !== "admin") {
    return res.status(403).json({ error: "Admin requis" });
  }
  
  next();
}

export function requireApp(appName: "stock" | "prix") {
  return (req: Request, res: Response, next: NextFunction) => {
    const user = (req as any).user as JWTPayload;
    
    if (!user) {
      return res.status(401).json({ error: "Non authentifi√©" });
    }
    
    if (user.role === "admin") {
      return next();
    }
    
    if (!user.apps.includes(appName)) {
      return res.status(403).json({ error: `Acc√®s refus√© √† ${appName}` });
    }
    
    next();
  };
}
PARTIE 4 : BACKEND - ROUTES AUTH
File: server/routes/auth.ts (CR√âER)
import express from "express";
import { db } from "../db";
import { users } from "../../shared/schema-users";
import { eq } from "drizzle-orm";
import { generateToken, verifyToken } from "../middleware/auth";
import { encryptPassword, decryptPassword } from "../utils/password-crypto";

const router = express.Router();

router.post("/login", async (req, res) => {
  try {
    const { username, password } = req.body;
    
    if (!username || !password) {
      return res.status(400).json({ error: "Username et password requis" });
    }
    
    const [user] = await db
      .select()
      .from(users)
      .where(eq(users.username, username))
      .limit(1);
    
    if (!user || !user.actif) {
      return res.status(401).json({ error: "Identifiants incorrects" });
    }
    
    const storedPassword = decryptPassword(user.passwordEncrypted);
    
    if (password !== storedPassword) {
      return res.status(401).json({ error: "Identifiants incorrects" });
    }
    
    const apps: string[] = [];
    if (user.peutAccesPrix) {
      apps.push('prix', 'stock');
    } else if (user.peutAccesStock) {
      apps.push('stock');
    }
    
    if (apps.length === 0) {
      return res.status(403).json({ error: "Aucune permission" });
    }
    
    await db
      .update(users)
      .set({ derniereConnexion: new Date() })
      .where(eq(users.id, user.id));
    
    const token = generateToken({
      userId: user.id,
      username: user.username,
      nom: user.nom,
      role: user.role as "admin" | "user",
      apps,
    });
    
    res.cookie("auth_token", token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "strict",
      maxAge: 7 * 24 * 60 * 60 * 1000,
    });
    
    res.json({
      user: {
        id: user.id,
        username: user.username,
        nom: user.nom,
        role: user.role,
        apps,
      },
    });
  } catch (error: any) {
    console.error("Erreur login:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});

router.post("/logout", (req, res) => {
  res.clearCookie("auth_token");
  res.json({ success: true });
});

router.get("/me", (req, res) => {
  const token = req.cookies?.auth_token;
  
  if (!token) {
    return res.status(401).json({ error: "Non authentifi√©" });
  }
  
  const payload = verifyToken(token);
  
  if (!payload) {
    res.clearCookie("auth_token");
    return res.status(401).json({ error: "Token invalide" });
  }
  
  res.json({ user: payload });
});

router.get("/usernames", async (req, res) => {
  try {
    const activeUsers = await db
      .select({ username: users.username })
      .from(users)
      .where(eq(users.actif, true))
      .orderBy(users.username);
    
    res.json(activeUsers.map(u => u.username));
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

export default router;
File: server/routes/users.ts (CR√âER)
import express from "express";
import { db } from "../db";
import { users } from "../../shared/schema-users";
import { eq } from "drizzle-orm";
import { requireAuth, requireAdmin } from "../middleware/auth";
import { encryptPassword, decryptPassword } from "../utils/password-crypto";

const router = express.Router();

router.use(requireAuth);
router.use(requireAdmin);

router.get("/", async (req, res) => {
  try {
    const allUsers = await db.select().from(users).orderBy(users.username);
    
    const usersWithPasswords = allUsers.map(user => ({
      ...user,
      password: decryptPassword(user.passwordEncrypted),
    }));
    
    res.json(usersWithPasswords);
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

router.post("/", async (req, res) => {
  try {
    const { username, nom, email, password, peut_acces_stock, peut_acces_prix, role } = req.body;
    
    if (!username || !nom || !password) {
      return res.status(400).json({ error: "Champs requis manquants" });
    }
    
    const [existing] = await db.select().from(users).where(eq(users.username, username)).limit(1);
    
    if (existing) {
      return res.status(400).json({ error: "Username d√©j√† utilis√©" });
    }
    
    const passwordEncrypted = encryptPassword(password);
    
    const [newUser] = await db.insert(users).values({
      username,
      nom,
      email: email || null,
      passwordEncrypted,
      peutAccesStock: peut_acces_stock || false,
      peutAccesPrix: peut_acces_prix || false,
      role: role || "user",
      createdBy: (req as any).user.nom,
    }).returning();
    
    res.json({ ...newUser, password: decryptPassword(newUser.passwordEncrypted) });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

router.patch("/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const { nom, email, password, peut_acces_stock, peut_acces_prix, role, actif } = req.body;
    
    const updateData: any = { updatedAt: new Date() };
    
    if (nom !== undefined) updateData.nom = nom;
    if (email !== undefined) updateData.email = email || null;
    if (peut_acces_stock !== undefined) updateData.peutAccesStock = peut_acces_stock;
    if (peut_acces_prix !== undefined) updateData.peutAccesPrix = peut_acces_prix;
    if (role !== undefined) updateData.role = role;
    if (actif !== undefined) updateData.actif = actif;
    
    if (password !== undefined && password !== "") {
      updateData.passwordEncrypted = encryptPassword(password);
    }
    
    const [updated] = await db.update(users).set(updateData).where(eq(users.id, parseInt(id))).returning();
    
    if (!updated) {
      return res.status(404).json({ error: "User non trouv√©" });
    }
    
    res.json({ ...updated, password: decryptPassword(updated.passwordEncrypted) });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

router.delete("/:id", async (req, res) => {
  try {
    const { id } = req.params;
    
    if (parseInt(id) === (req as any).user.userId) {
      return res.status(400).json({ error: "Vous ne pouvez pas supprimer votre propre compte" });
    }
    
    await db.delete(users).where(eq(users.id, parseInt(id)));
    res.json({ success: true });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

export default router;
PARTIE 5 : BACKEND - INT√âGRATION
File: server/index.ts
AJOUTER ces imports et middleware :
import cookieParser from "cookie-parser";
import authRoutes from "./routes/auth";
import usersRoutes from "./routes/users";
import { requireAuth, requireApp } from "./middleware/auth";

// Apr√®s app = express()
app.use(cookieParser()); // ‚Üê AJOUTER

// Routes publiques (AVANT les routes prot√©g√©es)
app.use("/api/auth", authRoutes); // ‚Üê AJOUTER

// Routes admin
app.use("/api/users", usersRoutes); // ‚Üê AJOUTER

// Prot√©ger routes r√©f√©rentiel (AVANT vos routes existantes)
app.use("/api/referentiel/*", requireAuth); // ‚Üê AJOUTER
app.use("/api/referentiel/*", requireApp('prix')); // ‚Üê AJOUTER

// Prot√©ger routes prix
app.use("/api/prix/*", requireAuth); // ‚Üê AJOUTER
app.use("/api/prix/*", requireApp('prix')); // ‚Üê AJOUTER
Tra√ßabilit√© : Ajouter user.nom dans routes existantes
Dans TOUTES vos routes PATCH/POST existantes, ajouter :
// Exemple : modification produit
app.patch("/api/referentiel/produits/:id", async (req, res) => {
  const userName = (req as any).user.nom; // ‚Üê AJOUTER
  
  await db.update(produitsMaster).set({
    ...updateData,
    modifiePar: userName, // ‚Üê AJOUTER
    dateModification: new Date(),
  });
});

// Exemple : cr√©ation produit
app.post("/api/referentiel/produits", async (req, res) => {
  const userName = (req as any).user.nom; // ‚Üê AJOUTER
  
  await db.insert(produitsMaster).values({
    ...data,
    creePar: userName, // ‚Üê AJOUTER
    modifiePar: userName,
  });
});
R√©p√©ter pour toutes routes de modification (cat√©gories, prix, fournisseurs, etc.).
PARTIE 6 : FRONTEND - AUTH CONTEXT
File: client/src/contexts/AuthContext.tsx (CR√âER)
import { createContext, useContext, useState, useEffect, ReactNode } from "react";
import { apiRequest } from "@/lib/apiRequest";

interface User {
  id: number;
  username: string;
  nom: string;
  role: "admin" | "user";
  apps: string[];
}

interface AuthContextType {
  user: User | null;
  isLoading: boolean;
  login: (username: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  isAdmin: boolean;
  canAccessApp: (appName: string) => boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  
  useEffect(() => {
    checkAuth();
  }, []);
  
  async function checkAuth() {
    try {
      const response = await apiRequest("GET", "/api/auth/me");
      setUser(response.user);
    } catch (error) {
      setUser(null);
    } finally {
      setIsLoading(false);
    }
  }
  
  async function login(username: string, password: string) {
    const response = await apiRequest("POST", "/api/auth/login", { username, password });
    setUser(response.user);
  }
  
  async function logout() {
    await apiRequest("POST", "/api/auth/logout");
    setUser(null);
  }
  
  function canAccessApp(appName: string): boolean {
    if (!user) return false;
    if (user.role === "admin") return true;
    return user.apps.includes(appName);
  }
  
  return (
    <AuthContext.Provider value={{ user, isLoading, login, logout, isAdmin: user?.role === "admin", canAccessApp }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) throw new Error("useAuth must be used within AuthProvider");
  return context;
}
File: client/src/components/ProtectedRoute.tsx (CR√âER)
import { useEffect } from "react";
import { useLocation, Redirect } from "wouter";
import { useAuth } from "@/contexts/AuthContext";

interface ProtectedRouteProps {
  component: React.ComponentType<any>;
  adminOnly?: boolean;
  [key: string]: any;
}

export default function ProtectedRoute({ component: Component, adminOnly = false, ...rest }: ProtectedRouteProps) {
  const { user, isLoading } = useAuth();
  const [, setLocation] = useLocation();
  
  useEffect(() => {
    if (!isLoading && !user) {
      setLocation("/login");
    }
  }, [user, isLoading, setLocation]);
  
  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
      </div>
    );
  }
  
  if (!user) return <Redirect to="/login" />;
  
  if (adminOnly && user.role !== "admin") {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <h1 className="text-2xl text-red-600">Acc√®s refus√© - Admin requis</h1>
      </div>
    );
  }
  
  return <Component {...rest} />;
}
File: client/src/pages/Login.tsx (CR√âER - voir brief complet pour code UI complet)
File: client/src/pages/Users.tsx (CR√âER - voir brief complet pour code interface admin)
File: client/src/App.tsx
MODIFIER pour int√©grer auth :
import { AuthProvider } from "@/contexts/AuthContext";
import Login from "@/pages/Login";
import ProtectedRoute from "@/components/ProtectedRoute";
import Users from "@/pages/Users";

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <AuthProvider>
        <Switch>
          <Route path="/login" component={Login} />
          <ProtectedRoute path="/" component={Produits} />
          <ProtectedRoute path="/categories" component={Categories} />
          <ProtectedRoute path="/users" component={Users} adminOnly />
        </Switch>
        <Toaster />
      </AuthProvider>
    </QueryClientProvider>
  );
}
PARTIE 7 : INITIALISATION USERS
File: scripts/init-users.ts (CR√âER)
import { db } from "../server/db";
import { users } from "../shared/schema-users";
import { encryptPassword } from "../server/utils/password-crypto";

const INITIAL_USERS = [
  {
    username: "michael",
    nom: "Michael",
    email: "michael@filtreplante.com",
    password: "Michael@FP2026",
    peut_acces_stock: true,
    peut_acces_prix: true,
    role: "admin",
  },
  {
    username: "cheikh",
    nom: "Cheikh",
    email: null,
    password: "Cheikh@FP2026",
    peut_acces_stock: true,
    peut_acces_prix: false,
    role: "user",
  },
  {
    username: "fatou",
    nom: "Fatou",
    email: "fatou@filtreplante.com",
    password: "Fatou@FP2026",
    peut_acces_stock: true,
    peut_acces_prix: true,
    role: "user",
  },
  {
    username: "marine",
    nom: "Marine",
    email: null,
    password: "Marine@FP2026",
    peut_acces_stock: true,
    peut_acces_prix: true,
    role: "user",
  },
];

async function initUsers() {
  console.log("üöÄ Cr√©ation users...\n");
  
  for (const userData of INITIAL_USERS) {
    try {
      const passwordEncrypted = encryptPassword(userData.password);
      
      const [user] = await db.insert(users).values({
        username: userData.username,
        nom: userData.nom,
        email: userData.email,
        passwordEncrypted,
        peutAccesStock: userData.peut_acces_stock,
        peutAccesPrix: userData.peut_acces_prix,
        role: userData.role,
      }).returning();
      
      console.log(`‚úÖ ${user.username} ‚Üí ${userData.password}`);
    } catch (error: any) {
      if (error.message.includes("unique")) {
        console.log(`‚ö†Ô∏è  ${userData.username} existe d√©j√†`);
      } else {
        console.error(`‚ùå ${userData.username}:`, error.message);
      }
    }
  }
  
  console.log("\n‚úÖ Termin√©\n");
  process.exit(0);
}

initUsers();
Ex√©cuter :
npx tsx scripts/init-users.ts
TESTS
Backend :
 POST /api/auth/login avec michael/Michael@FP2026 ‚Üí JWT cookie
 GET /api/auth/me avec cookie ‚Üí retourne user
 GET /api/users avec admin ‚Üí liste users avec passwords
 GET /api/referentiel/produits sans auth ‚Üí 401
Frontend :
 /login affiche dropdown + password
 Login michael ‚Üí Acc√®s app
 Page /users accessible (admin)
 Logout ‚Üí Redirect /login
Tra√ßabilit√© :
 Modifier produit ‚Üí modifie_par rempli
 Cr√©er produit ‚Üí cree_par rempli
D√âPLOIEMENT
Variables env d√©finies (JWT_SECRET, PASSWORD_SECRET_KEY)
Table users cr√©√©e (migration SQL)
D√©pendances install√©es
Code backend/frontend int√©gr√©
Script init-users ex√©cut√©
Tests pass√©s
‚ö†Ô∏è NOTER JWT_SECRET et PASSWORD_SECRET_KEY ‚Üí Tu devras les copier dans GestionStockFP !