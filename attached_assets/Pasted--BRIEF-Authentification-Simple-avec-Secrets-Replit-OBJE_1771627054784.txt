# BRIEF : Authentification Simple avec Secrets Replit

## ğŸ¯ OBJECTIF
Ajouter une authentification par email/mot de passe en stockant les credentials dans les Secrets Replit (pas de hash, simplicitÃ© maximale).

## ğŸ‘¥ UTILISATEURS

3 utilisateurs fixes :

| Nom | Email | RÃ´le | Mot de passe |
|-----|-------|------|--------------|
| Marine | marine@filtreplante.com | admin | Fplante1! |
| Fatou | fatou@filtreplante.com | utilisateur | Fplante1! |
| Michael | michael@filtreplante.com | admin | Fatou1! |

**RÃ´les :**
- **admin** : AccÃ¨s complet
- **utilisateur** : AccÃ¨s lecture + mouvements (pas de gestion produits)

## ğŸ” STRATÃ‰GIE : Secrets Replit

**Configuration Secrets (dans Replit) :**
```
# Session
SESSION_SECRET=<gÃ©nÃ©rer-via-crypto.randomBytes(32).toString('hex')>

# Users (format : email:password:role)
AUTH_USERS=marine@filtreplante.com:Fplante1!:admin,fatou@filtreplante.com:Fplante1!:utilisateur,michael@filtreplante.com:Fatou1!:admin
```

**Pourquoi ce format :**
- Simple Ã  parser (split par `,` puis `:`)
- Tout dans 1 variable
- Facile Ã  modifier

## ğŸ› ï¸ IMPLÃ‰MENTATION BACKEND

### 1. Installer dÃ©pendance

```bash
npm install express-session
npm install --save-dev @types/express-session
```

### 2. Configurer express-session

Dans `server/index.ts` :
```typescript
import session from 'express-session';

// Configuration session
app.use(
  session({
    secret: process.env.SESSION_SECRET || 'change-me-in-production',
    resave: false,
    saveUninitialized: false,
    cookie: {
      maxAge: 30 * 24 * 60 * 60 * 1000, // 30 jours
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
    },
  })
);

// Typage TypeScript
declare module 'express-session' {
  interface SessionData {
    userEmail: string;
    userName: string;
    userRole: string;
  }
}
```

### 3. Parser les users depuis Secrets

CrÃ©er `server/auth/users.ts` :
```typescript
interface User {
  email: string;
  password: string;
  role: 'admin' | 'utilisateur';
  nom: string;
}

// Parser AUTH_USERS depuis les Secrets
function parseUsersFromEnv(): User[] {
  const authUsers = process.env.AUTH_USERS || '';
  
  if (!authUsers) {
    console.warn('âš ï¸ AUTH_USERS non dÃ©fini dans Secrets');
    return [];
  }
  
  return authUsers.split(',').map((userStr) => {
    const [email, password, role] = userStr.split(':');
    const nom = email.split('@')[0]; // "marine" depuis "marine@filtreplante.com"
    
    return {
      email: email.trim(),
      password: password.trim(),
      role: (role.trim() as 'admin' | 'utilisateur'),
      nom: nom.charAt(0).toUpperCase() + nom.slice(1), // "Marine"
    };
  });
}

export const USERS = parseUsersFromEnv();

// Helper : trouver un user par email
export function findUserByEmail(email: string): User | undefined {
  return USERS.find(u => u.email.toLowerCase() === email.toLowerCase());
}

// Helper : vÃ©rifier mot de passe
export function verifyPassword(user: User, password: string): boolean {
  return user.password === password;
}
```

### 4. Routes d'authentification

CrÃ©er `server/routes/auth.ts` :
```typescript
import { Router } from 'express';
import { findUserByEmail, verifyPassword } from '../auth/users';

const router = Router();

// POST /api/auth/login
router.post('/login', async (req, res) => {
  const { email, password } = req.body;
  
  if (!email || !password) {
    return res.status(400).json({ error: 'Email et mot de passe requis' });
  }
  
  // Trouver user
  const user = findUserByEmail(email);
  
  if (!user) {
    return res.status(401).json({ error: 'Email ou mot de passe incorrect' });
  }
  
  // VÃ©rifier mot de passe
  if (!verifyPassword(user, password)) {
    return res.status(401).json({ error: 'Email ou mot de passe incorrect' });
  }
  
  // CrÃ©er session
  req.session.userEmail = user.email;
  req.session.userName = user.nom;
  req.session.userRole = user.role;
  
  res.json({
    nom: user.nom,
    email: user.email,
    role: user.role,
  });
});

// POST /api/auth/logout
router.post('/logout', (req, res) => {
  req.session.destroy((err) => {
    if (err) {
      return res.status(500).json({ error: 'Erreur logout' });
    }
    res.clearCookie('connect.sid');
    res.json({ message: 'DÃ©connectÃ©' });
  });
});

// GET /api/auth/me
router.get('/me', (req, res) => {
  if (!req.session.userEmail) {
    return res.status(401).json({ error: 'Non authentifiÃ©' });
  }
  
  const user = findUserByEmail(req.session.userEmail);
  
  if (!user) {
    req.session.destroy(() => {});
    return res.status(401).json({ error: 'Utilisateur introuvable' });
  }
  
  res.json({
    nom: user.nom,
    email: user.email,
    role: user.role,
  });
});

export default router;
```

Importer dans `server/index.ts` :
```typescript
import authRoutes from './routes/auth';
app.use('/api/auth', authRoutes);
```

### 5. Middleware de protection

CrÃ©er `server/middleware/requireAuth.ts` :
```typescript
import { Request, Response, NextFunction } from 'express';

export function requireAuth(req: Request, res: Response, next: NextFunction) {
  if (!req.session.userEmail) {
    return res.status(401).json({ error: 'Authentification requise' });
  }
  next();
}

export function requireAdmin(req: Request, res: Response, next: NextFunction) {
  if (!req.session.userEmail) {
    return res.status(401).json({ error: 'Authentification requise' });
  }
  if (req.session.userRole !== 'admin') {
    return res.status(403).json({ error: 'AccÃ¨s admin requis' });
  }
  next();
}
```

Appliquer aux routes :
```typescript
import { requireAuth, requireAdmin } from './middleware/requireAuth';

// Routes publiques
app.use('/api/auth', authRoutes);

// Routes protÃ©gÃ©es
app.use('/api/products', requireAuth, productsRoutes);
app.use('/api/movements', requireAuth, movementsRoutes);
app.use('/api/listes', requireAuth, listesRoutes);
```

## ğŸ¨ FRONTEND (identique au brief prÃ©cÃ©dent)

### Page de login

CrÃ©er `client/src/pages/LoginPage.tsx` :
```typescript
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useMutation } from '@tanstack/react-query';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useToast } from '@/hooks/use-toast';

export default function LoginPage() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const navigate = useNavigate();
  const { toast } = useToast();
  
  const loginMutation = useMutation({
    mutationFn: async (credentials: { email: string; password: string }) => {
      const res = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials),
        credentials: 'include',
      });
      
      if (!res.ok) {
        const error = await res.json();
        throw new Error(error.error || 'Erreur de connexion');
      }
      
      return res.json();
    },
    onSuccess: (user) => {
      toast({
        title: 'Connexion rÃ©ussie',
        description: `Bienvenue ${user.nom}`,
      });
      navigate('/');
    },
    onError: (error: Error) => {
      toast({
        title: 'Erreur de connexion',
        description: error.message,
        variant: 'destructive',
      });
    },
  });
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    loginMutation.mutate({ email, password });
  };
  
  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-teal-50 to-cyan-50">
      <div className="w-full max-w-md p-8 bg-white rounded-lg shadow-lg">
        <div className="text-center mb-8">
          <h1 className="text-3xl font-bold text-teal-600">Filtreplante</h1>
          <p className="text-gray-600 mt-2">Gestion de Stock</p>
        </div>
        
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <Label htmlFor="email">Email</Label>
            <Input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder="email@filtreplante.com"
              required
            />
          </div>
          
          <div>
            <Label htmlFor="password">Mot de passe</Label>
            <Input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
              required
            />
          </div>
          
          <Button
            type="submit"
            className="w-full bg-teal-600 hover:bg-teal-700"
            disabled={loginMutation.isPending}
          >
            {loginMutation.isPending ? 'Connexion...' : 'Se connecter'}
          </Button>
        </form>
      </div>
    </div>
  );
}
```

### Protection des routes (identique)

CrÃ©er `client/src/components/ProtectedRoute.tsx` + modifier router (mÃªme code que brief prÃ©cÃ©dent).

### Bouton dÃ©connexion (identique)

Ajouter LogoutButton dans header (mÃªme code que brief prÃ©cÃ©dent).

## ğŸ“ CONFIGURATION REPLIT SECRETS

Dans Replit â†’ Secrets (ğŸ”’), ajouter :

**1. SESSION_SECRET**
```
SESSION_SECRET=<gÃ©nÃ©rer-via-node>
```

Pour gÃ©nÃ©rer :
```bash
node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
```

**2. AUTH_USERS**
```
AUTH_USERS=marine@filtreplante.com:Fplante1!:admin,fatou@filtreplante.com:Fplante1!:utilisateur,michael@filtreplante.com:Fatou1!:admin
```

**Format** : `email:password:role,email:password:role,...`

## âœ… CHECKLIST DE VALIDATION

**Backend :**
- [ ] Variable `AUTH_USERS` parsÃ©e correctement
- [ ] Route `POST /api/auth/login` fonctionne
- [ ] Route `GET /api/auth/me` retourne user si authentifiÃ©
- [ ] Route `POST /api/auth/logout` dÃ©truit session
- [ ] Middleware `requireAuth` protÃ¨ge les routes

**Frontend :**
- [ ] Page `/login` affichÃ©e
- [ ] Login avec marine@filtreplante.com / Fplante1! â†’ OK
- [ ] Login avec fatou@filtreplante.com / Fplante1! â†’ OK
- [ ] Login avec michael@filtreplante.com / Fatou1! â†’ OK
- [ ] Mauvais mot de passe â†’ erreur
- [ ] Routes protÃ©gÃ©es redirigent vers /login
- [ ] DÃ©connexion fonctionne

## ğŸ”„ MODIFIER UN MOT DE PASSE

**Super simple avec Option B :**

1. Aller dans Replit â†’ Secrets
2. Modifier `AUTH_USERS` (remplacer le mot de passe)
3. RedÃ©marrer le Repl
4. C'est tout ! (30 secondes)

**Exemple :** Changer le mot de passe de Fatou :
```
# Avant
AUTH_USERS=marine@filtreplante.com:Fplante1!:admin,fatou@filtreplante.com:Fplante1!:utilisateur,michael@filtreplante.com:Fatou1!:admin

# AprÃ¨s
AUTH_USERS=marine@filtreplante.com:Fplante1!:admin,fatou@filtreplante.com:NouveauMdp123!:utilisateur,michael@filtreplante.com:Fatou1!:admin
```

## ğŸš€ DÃ‰PLOIEMENT

1. Ajouter `SESSION_SECRET` et `AUTH_USERS` dans Secrets
2. RedÃ©marrer le Repl
3. Tester le login avec les 3 comptes
4. Si OK â†’ Brief 2 (migration produits)